<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>å•è¯å¬å†™</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <style>
        :root {
            --background-color: #F5F5F7;
            --border-color: #D1D1D6;
            --button-bg: #F2F2F7;
            --button-text: #1D1D1F;
            --primary-blue: #007AFF;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--background-color);
            color: #1D1D1F;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 500px;
            background: white;
            border-radius: 18px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        h1 {
            font-size: 22px;
            font-weight: 600;
            text-align: center;
            margin: 0 0 24px;
        }

        .file-input {
            margin-bottom: 24px;
            display: flex;
            justify-content: center;
        }

        .custom-file-input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--background-color);
            font-size: 15px;
            cursor: pointer;
        }

        .control-bar {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            background: var(--button-bg);
            color: var(--button-text);
            border: 1px solid var(--border-color);
            padding: 12px;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        button:hover:not(:disabled) {
            background: #E5E5EA;
        }

        button:disabled {
            opacity: 0.4;
            border-color: transparent;
        }

        .export-button {
            background: white;
            grid-column: 1 / -1;
        }

        .word-card {
            background: var(--background-color);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            text-align: center;
        }

        .current-word {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .definition {
            font-size: 16px;
            color: #666;
            line-height: 1.5;
        }

        .input-group {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            font-size: 16px;
        }

        .feedback {
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 16px;
            text-align: center;
            display: none;
        }

        .correct {
            background: #DDFFDD;
            color: #228B22;
        }

        .incorrect {
            background: #FFEBE6;
            color: #FF3B30;
        }

        .history-panel {
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>å•è¯å¬å†™</h1>

        <div class="file-input">
            <input type="file" id="fileInput" accept=".txt,.docx" class="custom-file-input">
        </div>

        <div class="control-bar">
            <button id="startButton">â–¶ï¸ å¼€å§‹</button>
            <button id="replayButton">ğŸ”Š é‡æ’­</button>
            <button id="showWordButton">ğŸ‘€ æ˜¾ç¤ºç­”æ¡ˆ</button>
            <button id="nextButton">â­ï¸ ä¸‹ä¸€ä¸ª</button>
            <button id="endButton" class="export-button">â¹ï¸ ç»“æŸå¹¶å¯¼å‡º</button>
        </div>

        <div class="word-card">
            <div class="current-word">å‡†å¤‡å¥½å¼€å§‹å¬å†™</div>
            <div class="definition" id="definition"></div>
        </div>

        <div class="input-group">
            <input type="text" id="userInput" placeholder="è¾“å…¥ä½ å¬åˆ°çš„å•è¯" disabled>
            <button id="submitButton" disabled>æäº¤</button>
        </div>

        <div class="feedback" id="feedback"></div>

        <div class="history-panel">
            <h3>å¬å†™å†å²</h3>
            <div id="historyList"></div>
        </div>
    </div>

    <script>
        let wordList = [];
        let currentIndex = 0;
        let history = [];
        let missedWords = [];

        // DOM Elements
        const elements = {
            fileInput: document.getElementById('fileInput'),
            startButton: document.getElementById('startButton'),
            replayButton: document.getElementById('replayButton'),
            showWordButton: document.getElementById('showWordButton'),
            nextButton: document.getElementById('nextButton'),
            endButton: document.getElementById('endButton'),
            userInput: document.getElementById('userInput'),
            submitButton: document.getElementById('submitButton'),
            currentWord: document.querySelector('.current-word'),
            definition: document.getElementById('definition'),
            feedback: document.getElementById('feedback'),
            historyList: document.getElementById('historyList')
        };

        // åˆå§‹åŒ–çŠ¶æ€
        function updateUIState() {
            const hasWords = wordList.length > 0;
            const controls = ['startButton', 'replayButton', 'showWordButton', 'nextButton', 'endButton'];
            controls.forEach(control => elements[control].disabled = !hasWords);
            elements.userInput.disabled = !hasWords;
            elements.submitButton.disabled = !hasWords;
        }

        // æ–‡ä»¶å¤„ç†
        elements.fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const content = await (file.type === 'text/plain'
                    ? readTextFile(file)
                    : readDocxFile(file));

                wordList = content.split(/\s+/).filter(w => w);
                if (!wordList.length) throw new Error('æ²¡æœ‰æ£€æµ‹åˆ°å•è¯');

                currentIndex = 0;
                history = [];
                missedWords = [];
                updateUIState();
                showFeedback(`æˆåŠŸåŠ è½½ ${wordList.length} ä¸ªå•è¯`, '#007AFF');
            } catch (error) {
                showFeedback(error.message, '#FF3B30');
            }
        });

        async function readTextFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = () => reject('è¯»å–æ–‡ä»¶å¤±è´¥');
                reader.readAsText(file);
            });
        }

        async function readDocxFile(file) {
            const arrayBuffer = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = () => reject('è¯»å–æ–‡ä»¶å¤±è´¥');
                reader.readAsArrayBuffer(file);
            });

            const result = await mammoth.extractRawText({ arrayBuffer });
            return result.value;
        }

        // å‘éŸ³åŠŸèƒ½
        function speakWord(word) {
            const utterance = new SpeechSynthesisUtterance(word);
            utterance.lang = 'en-US';
            speechSynthesis.speak(utterance);
        }

        // æ˜¾ç¤ºåé¦ˆ
        function showFeedback(message, color) {
            elements.feedback.style.display = 'block';
            elements.feedback.textContent = message;
            elements.feedback.style.background = `${color}22`;
            elements.feedback.style.color = color;
            setTimeout(() => elements.feedback.style.display = 'none', 2000);
        }

        // æäº¤ç­”æ¡ˆ
        elements.submitButton.addEventListener('click', checkAnswer);
        elements.userInput.addEventListener('keypress', e => e.key === 'Enter' && checkAnswer());

        function checkAnswer() {
            const userAnswer = elements.userInput.value.trim();
            const correctAnswer = wordList[currentIndex];
            const isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();

            // è®°å½•å†å²
            history.push({ word: correctAnswer, input: userAnswer, correct: isCorrect });
            if (!isCorrect) missedWords.push({ input: userAnswer, correct: correctAnswer });

            // æ˜¾ç¤ºåé¦ˆ
            showFeedback(isCorrect ? 'âœ“ æ‹¼å†™æ­£ç¡®ï¼' : `âœ• æ­£ç¡®ï¼š${correctAnswer}`, isCorrect ? '#34C759' : '#FF3B30');

            // å‡†å¤‡ä¸‹ä¸€ä¸ªå•è¯
            elements.userInput.value = '';
            currentIndex = (currentIndex + 1) % wordList.length;
            speakWord(wordList[currentIndex]);
            updateHistoryDisplay();
        }

        // æ˜¾ç¤ºå•è¯é‡Šä¹‰
        elements.showWordButton.addEventListener('click', async () => {
            elements.currentWord.textContent = wordList[currentIndex];
            elements.definition.innerHTML = 'åŠ è½½é‡Šä¹‰ä¸­...';

            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${wordList[currentIndex]}`);
                const data = await response.json();
                elements.definition.innerHTML = data[0].meanings
                    .map(m => `<div>${m.partOfSpeech}: ${m.definitions[0].definition}</div>`)
                    .join('');
            } catch (error) {
                elements.definition.textContent = 'æ— æ³•è·å–é‡Šä¹‰';
            }
        });

        // æ›´æ–°å†å²è®°å½•
        function updateHistoryDisplay() {
            elements.historyList.innerHTML = history
                .slice(-5)
                .map(item => `
                    <div class="history-item ${item.correct ? 'correct' : 'incorrect'}">
                        <span>${item.word}</span>
                        <span>${item.input || 'æœªè¾“å…¥'}</span>
                        <span>${item.correct ? 'âœ“' : 'âœ•'}</span>
                    </div>`
                )
                .join('');
        }

        // å¯¼å‡ºé”™è¯¯å•è¯
        elements.endButton.addEventListener('click', () => {
            if (!missedWords.length) return showFeedback('æ²¡æœ‰éœ€è¦å¯¼å‡ºçš„é”™è¯¯å•è¯', '#34C759');

            const content = missedWords.map(item =>
                `ä½ çš„è¾“å…¥: ${item.input}\næ­£ç¡®ç­”æ¡ˆ: ${item.correct}\n${'-'.repeat(20)}`
            ).join('\n');

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `æ‹¼å†™é”™è¯¯_${new Date().toLocaleDateString().replace(/\//g, '-')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showFeedback(`å·²å¯¼å‡º ${missedWords.length} ä¸ªé”™è¯¯`, '#34C759');
        });

        // ç»‘å®šæ§åˆ¶æŒ‰é’®
        elements.startButton.addEventListener('click', () => {
            currentIndex = 0;
            speakWord(wordList[currentIndex]);
            elements.userInput.disabled = false;
            elements.submitButton.disabled = false;
        });

        elements.replayButton.addEventListener('click', () => speakWord(wordList[currentIndex]));
        elements.nextButton.addEventListener('click', () => {
            currentIndex = (currentIndex + 1) % wordList.length;
            speakWord(wordList[currentIndex]);
        });
    </script>
</body>

</html>